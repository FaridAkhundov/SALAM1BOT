{"file_contents":{"config.py":{"content":"\"\"\"\nConfiguration settings for the Telegram YouTube to MP3 Bot\n\"\"\"\n\nimport os\n\n# Telegram Bot Token - get from environment variable\nBOT_TOKEN = os.getenv(\"TELEGRAM_BOT_TOKEN\", \"8115293466:AAFDIc6ZJ-iaKUXyNwdhdQEIkXapbpCIGCU\")\n\n# File size limits (Telegram has 50MB limit)\nMAX_FILE_SIZE_MB = 45  # Leave some buffer\nMAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024\n\n# Download settings\nDOWNLOAD_TIMEOUT = 60  # 1 minute\nTEMP_DIR = \"temp_downloads\"\n\n# Rate limiting (simple per-user)\nRATE_LIMIT_SECONDS = 30  # Minimum time between requests per user\n\n# Audio quality settings\nAUDIO_QUALITY = \"192\"  # 192 kbps\nAUDIO_FORMAT = \"mp3\"\n\n# Bot messages\nWELCOME_MESSAGE = \"\"\"\nüéµ *YouTube-dan MP3 √áevirici Bot* üéµ\n\nXo≈ü g…ôlmisiniz! M…ôn sizin √º√ß√ºn YouTube videolarƒ±nƒ± MP3 fayllarƒ±na √ßevir…ô bil…ôr…ôm.\n\n*Nec…ô istifad…ô etm…ôk:*\n‚Ä¢ Birba≈üa y√ºkl…ôm…ôk √º√ß√ºn YouTube video linkini g√∂nd…ôrin\n‚Ä¢ Mahnƒ± adƒ±nƒ± yazƒ±n v…ô n…ôtic…ôl…ôrd…ôn se√ßin\n‚Ä¢ M…ôn onu y√ºkl…ôyib MP3-…ô √ßevir…ôr…ôm\n‚Ä¢ Audio faylƒ± alacaqsƒ±nƒ±z\n\n*∆èmrl…ôr:*\n/start - Bu xo≈ü g…ôldin mesajƒ±nƒ± g√∂st…ôr\n/help - K√∂m…ôk v…ô istifad…ô t…ôlimatlarƒ±\n\n*Qeyd:* Telegram limitl…ôrin…ô g√∂r…ô 45MB-dan b√∂y√ºk fayllar g√∂nd…ôril…ô bilm…ôz.\n\"\"\"\n\nHELP_MESSAGE = \"\"\"\nüîß *K√∂m…ôk v…ô T…ôlimatlar* üîß\n\n*Musiqi almaƒüƒ±n iki yolu:*\n1. *Birba≈üa Link:* D…ôrhal y√ºkl…ôm…ôk √º√ß√ºn YouTube linki g√∂nd…ôrin\n2. *Axtarƒ±≈ü:* H…ôr hansƒ± mahnƒ± adƒ± yazƒ±n v…ô axtarƒ±≈ü n…ôtic…ôl…ôrind…ôn se√ßin\n\n*D…ôst…ôkl…ôn…ôn Linkl…ôr:*\n‚Ä¢ youtube.com/watch?v=...\n‚Ä¢ youtu.be/...\n‚Ä¢ m.youtube.com/watch?v=...\n\n*Axtarƒ±≈ü X√ºsusiyy…ôtl…ôri:*\n‚Ä¢ H…ôr axtarƒ±≈üda 24-…ô q…ôd…ôr n…ôtic…ô\n‚Ä¢ H…ôr s…ôhif…ôd…ô 8 mahnƒ±, maksimum 3 s…ôhif…ô\n‚Ä¢ ∆èvv…ôlki/N√∂vb…ôti d√ºym…ôl…ôri il…ô asan naviqasiya\n\n*X√ºsusiyy…ôtl…ôr:*\n‚Ä¢ Y√ºks…ôk keyfiyy…ôtli MP3 √ßevrilm…ôsi (192 kbps)\n‚Ä¢ Avtomatik fayl t…ômizliyi\n‚Ä¢ Yanlƒ±≈ü linkl…ôr √º√ß√ºn x…ôta idar…ôetm…ôsi\n‚Ä¢ Fayl √∂l√ß√ºs√º yoxlanmasƒ±\n\n*M…ôhdudiyy…ôtl…ôr:*\n‚Ä¢ Maksimum fayl √∂l√ß√ºs√º: 45MB\n‚Ä¢ M…ôhdudiyy…ôt: H…ôr istifad…ô√ßi √º√ß√ºn 30 saniy…ôd…ô bir sorƒüu\n‚Ä¢ Yalnƒ±z YouTube videolarƒ±\n\n*Problem ya≈üayƒ±rsƒ±nƒ±z?*\nYouTube linkinizin etibarlƒ± olduƒüundan v…ô videonun ictimai …ôl√ßatan olduƒüundan …ômin olun.\n\"\"\"\n\nERROR_MESSAGES = {\n    \"invalid_url\": \"‚ùå Yanlƒ±≈ü YouTube linki. Z…ôhm…ôt olmasa etibarlƒ± YouTube linki g√∂nd…ôrin.\",\n    \"download_failed\": \"‚ùå Video y√ºkl…ôn…ô bilm…ôdi. Z…ôhm…ôt olmasa linki yoxlayƒ±n v…ô yenid…ôn c…ôhd edin.\",\n    \"file_too_large\": f\"‚ùå Fayl √ßox b√∂y√ºkd√ºr ({MAX_FILE_SIZE_MB}MB-dan √ßox). Telegram bu q…ôd…ôr b√∂y√ºk fayllarƒ± d…ôst…ôkl…ômir.\",\n    \"conversion_failed\": \"‚ùå Video MP3-…ô √ßevril…ô bilm…ôdi. Z…ôhm…ôt olmasa yenid…ôn c…ôhd edin.\",\n    \"rate_limited\": f\"‚è∞ Z…ôhm…ôt olmasa sorƒüular arasƒ±nda {RATE_LIMIT_SECONDS} saniy…ô g√∂zl…ôyin.\",\n    \"general_error\": \"‚ùå X…ôta ba≈ü verdi. Z…ôhm…ôt olmasa sonra yenid…ôn c…ôhd edin.\"\n}\n","size_bytes":2904},"main.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTelegram YouTube to MP3 Bot\nMain entry point for the bot application\n\"\"\"\n\nimport logging\nimport asyncio\nfrom telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters\nfrom config import BOT_TOKEN\nfrom bot.handlers import start_handler, help_handler, message_handler, button_callback_handler, error_handler\n\n# Configure logging\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    level=logging.INFO\n)\nlogger = logging.getLogger(__name__)\n\ndef main():\n    \"\"\"Main function to start the bot\"\"\"\n    # Create the Application\n    application = Application.builder().token(BOT_TOKEN).build()\n    \n    # Add handlers\n    application.add_handler(CommandHandler(\"start\", start_handler))\n    application.add_handler(CommandHandler(\"help\", help_handler))\n    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, message_handler))\n    application.add_handler(CallbackQueryHandler(button_callback_handler))\n    \n    # Add error handler\n    application.add_error_handler(error_handler)\n    \n    # Start the bot\n    logger.info(\"Starting YouTube to MP3 Bot...\")\n    application.run_polling(allowed_updates=[\"message\", \"callback_query\"])\n\nif __name__ == '__main__':\n    main()\n","size_bytes":1283},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"ffmpeg-python>=0.2.0\",\n    \"python-telegram-bot>=22.3\",\n    \"telegram>=0.0.1\",\n    \"yt-dlp>=2025.7.21\",\n]\n","size_bytes":253},"replit.md":{"content":"# Overview\n\nThis is a Telegram bot that converts YouTube videos to MP3 files with advanced music search capabilities. The bot interface is fully localized in Azerbaijani language. Users can either send YouTube URLs for direct download or search for songs by name. The bot displays search results in paginated inline keyboards (8 songs per page, up to 3 pages) for easy selection. It downloads videos, extracts audio, converts to MP3 format, and sends the audio file back via Telegram. The bot includes rate limiting, file size validation, and comprehensive error handling with user-friendly Azerbaijani messages.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\nBot Interface Language: Azerbaijani (all user-facing messages, commands, and responses)\n\n# System Architecture\n\n## Bot Framework\n- **Technology**: Built using `python-telegram-bot` library for handling Telegram Bot API interactions\n- **Architecture Pattern**: Handler-based event-driven system with separate modules for different concerns\n- **Entry Point**: `main.py` sets up the application, registers handlers, and starts polling for updates\n\n## Message Processing Pipeline\n- **Command Handlers**: Separate handlers for `/start` and `/help` commands that display informational messages\n- **Smart Message Handler**: Intelligently processes text messages, distinguishing between YouTube URLs and song search queries\n- **Music Search System**: Provides YouTube search functionality with paginated inline keyboards (8 results per page, maximum 3 pages)\n- **Callback Query Handler**: Manages user interactions with inline keyboard buttons for song selection and page navigation\n- **Error Handler**: Global error handling for graceful failure management\n\n## Rate Limiting System\n- **Implementation**: Simple in-memory dictionary storing user ID and last request timestamp\n- **Policy**: 30-second minimum interval between requests per user to prevent abuse\n- **Storage**: Ephemeral storage that resets when bot restarts\n\n## Media Processing Engine\n- **Library**: Uses `yt-dlp` (YouTube downloader) for video extraction, search functionality, and `FFmpeg` for audio conversion\n- **Search Capabilities**: YouTube search with configurable result limits (up to 24 results per query)\n- **Quality Settings**: Fixed 192 kbps MP3 output format for consistent file sizes\n- **File Management**: Temporary file system with automatic cleanup after processing\n- **Size Constraints**: 45MB file size limit (5MB buffer under Telegram's 50MB limit)\n- **User Session Management**: In-memory storage for search results with user-specific pagination states\n\n## Configuration Management\n- **Environment Variables**: Bot token retrieved from environment for security\n- **Centralized Config**: All settings, limits, and messages stored in `config.py` for easy modification\n- **Default Values**: Fallback values provided for development environments\n\n## File System Organization\n- **Modular Structure**: Separate modules for handlers, utilities, and YouTube processing\n- **Temporary Storage**: Local `temp_downloads` directory for intermediate files\n- **Cleanup Strategy**: Automatic file deletion after successful upload or on errors\n\n## Error Handling Strategy\n- **Validation Layer**: URL format validation before processing begins  \n- **Timeout Protection**: 5-minute download timeout to prevent hanging processes\n- **User Feedback**: Descriptive error messages for different failure scenarios\n- **Resource Management**: Guaranteed cleanup of temporary files even on failures\n\n# External Dependencies\n\n## Telegram Bot API\n- **Service**: Official Telegram Bot API for message handling and file uploads\n- **Authentication**: Bot token-based authentication\n- **Limitations**: 50MB file upload limit, polling-based message retrieval\n\n## YouTube Data Access\n- **Library**: `yt-dlp` for video metadata extraction and download\n- **Capabilities**: Supports multiple YouTube URL formats and video qualities\n- **Audio Extraction**: Handles format conversion from video containers\n\n## Media Processing\n- **Tool**: FFmpeg for audio format conversion and quality adjustment\n- **Usage**: Post-processing pipeline within yt-dlp for MP3 conversion\n- **Quality Control**: Bitrate normalization to 192 kbps\n\n## Python Runtime Environment\n- **Core Libraries**: `asyncio` for asynchronous operations, `logging` for monitoring\n- **File System**: Local storage for temporary file management\n- **Process Management**: Subprocess handling for media conversion tools","size_bytes":4508},"bot/handlers.py":{"content":"\"\"\"\nTelegram bot command and message handlers\n\"\"\"\n\nimport logging\nimport re\nfrom datetime import datetime, timedelta\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes\nfrom telegram.constants import ChatAction\nfrom config import WELCOME_MESSAGE, HELP_MESSAGE, ERROR_MESSAGES, RATE_LIMIT_SECONDS\nfrom bot.youtube_processor import YouTubeProcessor\nfrom bot.utils import is_valid_youtube_url, cleanup_temp_files\n\nlogger = logging.getLogger(__name__)\n\n# Simple in-memory rate limiting storage\nuser_last_request = {}\n\n# Store search results for pagination\nuser_search_results = {}\n\nasync def start_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Handle the /start command\"\"\"\n    await update.message.reply_text(\n        WELCOME_MESSAGE,\n        parse_mode='Markdown'\n    )\n\nasync def help_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Handle the /help command\"\"\"\n    await update.message.reply_text(\n        HELP_MESSAGE,\n        parse_mode='Markdown'\n    )\n\nasync def message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Handle text messages - both YouTube URLs and song search queries\"\"\"\n    user_id = update.effective_user.id\n    message_text = update.message.text.strip()\n    \n    # Check rate limiting\n    if user_id in user_last_request:\n        time_diff = datetime.now() - user_last_request[user_id]\n        if time_diff.total_seconds() < RATE_LIMIT_SECONDS:\n            await update.message.reply_text(ERROR_MESSAGES[\"rate_limited\"])\n            return\n    \n    # Update last request time\n    user_last_request[user_id] = datetime.now()\n    \n    # Check if message is a YouTube URL\n    if is_valid_youtube_url(message_text):\n        await process_youtube_url(update, context, message_text)\n    else:\n        # Treat as song search query\n        await process_song_search(update, context, message_text)\n\nasync def process_youtube_url(update: Update, context: ContextTypes.DEFAULT_TYPE, url: str) -> None:\n    \"\"\"Process YouTube URL for download\"\"\"\n    # Send typing indicator\n    await context.bot.send_chat_action(chat_id=update.effective_chat.id, action=ChatAction.TYPING)\n    \n    # Send processing message\n    processing_msg = await update.message.reply_text(\"üîÑ Sorƒüunuz emal olunur...\")\n    \n    try:\n        # Initialize YouTube processor\n        processor = YouTubeProcessor()\n        \n        # Update progress\n        await processing_msg.edit_text(\"üì• Video y√ºkl…ônir...\")\n        \n        # Download and convert\n        result = await processor.download_and_convert(url)\n        \n        if not result[\"success\"]:\n            await processing_msg.edit_text(result[\"error\"])\n            return\n        \n        # Update progress\n        await processing_msg.edit_text(\"üì§ MP3 faylƒ± y√ºkl…ônir...\")\n        \n        # Send the MP3 file\n        with open(result[\"file_path\"], 'rb') as audio_file:\n            # Clean title to avoid duplication\n            clean_title = result[\"title\"]\n            uploader = result[\"uploader\"]\n            \n            # If uploader is already in title, use title only\n            if uploader and uploader.lower() in clean_title.lower():\n                await context.bot.send_audio(\n                    chat_id=update.effective_chat.id,\n                    audio=audio_file,\n                    title=clean_title,\n                    duration=result[\"duration\"]\n                )\n            else:\n                await context.bot.send_audio(\n                    chat_id=update.effective_chat.id,\n                    audio=audio_file,\n                    title=clean_title,\n                    performer=uploader,\n                    duration=result[\"duration\"]\n                )\n        \n        # Delete processing message\n        await processing_msg.delete()\n        \n        # Clean up the file\n        cleanup_temp_files([result[\"file_path\"]])\n        \n    except Exception as e:\n        logger.error(f\"Error processing URL {url}: {str(e)}\")\n        await processing_msg.edit_text(ERROR_MESSAGES[\"general_error\"])\n\nasync def process_song_search(update: Update, context: ContextTypes.DEFAULT_TYPE, query: str) -> None:\n    \"\"\"Process song search query and display paginated results\"\"\"\n    user_id = update.effective_user.id\n    \n    # Send typing indicator\n    await context.bot.send_chat_action(chat_id=update.effective_chat.id, action=ChatAction.TYPING)\n    \n    # Send searching message\n    searching_msg = await update.message.reply_text(\"üîç Mahnƒ±lar axtarƒ±lƒ±r...\")\n    \n    try:\n        # Initialize YouTube processor\n        processor = YouTubeProcessor()\n        \n        # Search for videos\n        search_results = await processor.search_youtube(query, max_results=24)\n        \n        if not search_results:\n            await searching_msg.edit_text(\"‚ùå He√ß bir mahnƒ± tapƒ±lmadƒ±. F…ôrqli axtarƒ±≈ü s√∂z√º sƒ±nayƒ±n.\")\n            return\n        \n        # Store search results for pagination\n        user_search_results[user_id] = search_results\n        \n        # Create paginated keyboard for first page\n        keyboard = create_paginated_keyboard(search_results, page=0, user_id=user_id)\n        \n        await searching_msg.edit_text(\n            f\"üéµ *{query}* √º√ß√ºn {len(search_results)} mahnƒ± tapƒ±ldƒ±\\n\\nS…ôhif…ô 1/3 - Mahnƒ± se√ßin:\",\n            parse_mode='Markdown',\n            reply_markup=keyboard\n        )\n        \n    except Exception as e:\n        logger.error(f\"Error searching for '{query}': {str(e)}\")\n        await searching_msg.edit_text(ERROR_MESSAGES[\"general_error\"])\n\ndef create_paginated_keyboard(results: list, page: int, user_id: int) -> InlineKeyboardMarkup:\n    \"\"\"Create paginated inline keyboard with song buttons\"\"\"\n    buttons = []\n    start_idx = page * 8\n    end_idx = min(start_idx + 8, len(results))\n    \n    # Add song buttons (8 per page)\n    for i in range(start_idx, end_idx):\n        song = results[i]\n        # Truncate title if too long for button\n        display_title = song['title'][:50] + \"...\" if len(song['title']) > 50 else song['title']\n        buttons.append([InlineKeyboardButton(\n            f\"üéµ {display_title}\",\n            callback_data=f\"song_{user_id}_{i}\"\n        )])\n    \n    # Add navigation buttons\n    nav_buttons = []\n    total_pages = min(3, (len(results) + 7) // 8)  # Max 3 pages\n    \n    if page > 0:\n        nav_buttons.append(InlineKeyboardButton(\"‚¨ÖÔ∏è ∆èvv…ôlki\", callback_data=f\"page_{user_id}_{page-1}\"))\n    \n    if page < total_pages - 1 and page < 2:  # Max 3 pages (0, 1, 2)\n        nav_buttons.append(InlineKeyboardButton(\"N√∂vb…ôti ‚û°Ô∏è\", callback_data=f\"page_{user_id}_{page+1}\"))\n    \n    if nav_buttons:\n        buttons.append(nav_buttons)\n    \n    return InlineKeyboardMarkup(buttons)\n\nasync def button_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Handle inline keyboard button callbacks\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    user_id = update.effective_user.id\n    callback_data = query.data\n    \n    try:\n        if callback_data.startswith(\"song_\"):\n            # Handle song selection\n            _, cb_user_id, song_idx = callback_data.split(\"_\")\n            cb_user_id = int(cb_user_id)\n            song_idx = int(song_idx)\n            \n            # Verify user owns this search\n            if cb_user_id != user_id or user_id not in user_search_results:\n                await query.edit_message_text(\"‚ùå Bu axtarƒ±≈ü sessiyasƒ± bitib. Z…ôhm…ôt olmasa yenid…ôn axtarƒ±n.\")\n                return\n            \n            # Get selected song\n            search_results = user_search_results[user_id]\n            if song_idx >= len(search_results):\n                await query.edit_message_text(\"‚ùå Yanlƒ±≈ü se√ßim. Z…ôhm…ôt olmasa yenid…ôn axtarƒ±n.\")\n                return\n            \n            selected_song = search_results[song_idx]\n            \n            # Update message to show processing\n            await query.edit_message_text(f\"üîÑ Y√ºkl…ônir: {selected_song['title']}\")\n            \n            # Process the selected song\n            await process_youtube_url_from_callback(query, context, selected_song['url'], selected_song['title'])\n            \n        elif callback_data.startswith(\"page_\"):\n            # Handle page navigation\n            _, cb_user_id, page = callback_data.split(\"_\")\n            cb_user_id = int(cb_user_id)\n            page = int(page)\n            \n            # Verify user owns this search\n            if cb_user_id != user_id or user_id not in user_search_results:\n                await query.edit_message_text(\"‚ùå Bu axtarƒ±≈ü sessiyasƒ± bitib. Z…ôhm…ôt olmasa yenid…ôn axtarƒ±n.\")\n                return\n            \n            # Update keyboard for new page\n            search_results = user_search_results[user_id]\n            keyboard = create_paginated_keyboard(search_results, page, user_id)\n            \n            await query.edit_message_reply_markup(reply_markup=keyboard)\n            \n    except Exception as e:\n        logger.error(f\"Error handling button callback: {str(e)}\")\n        await query.edit_message_text(ERROR_MESSAGES[\"general_error\"])\n\nasync def process_youtube_url_from_callback(query, context: ContextTypes.DEFAULT_TYPE, url: str, title: str) -> None:\n    \"\"\"Process YouTube URL from button callback\"\"\"\n    try:\n        # Initialize YouTube processor\n        processor = YouTubeProcessor()\n        \n        # Update progress\n        await query.edit_message_text(f\"üì• Y√ºkl…ônir: {title}\")\n        \n        # Download and convert\n        result = await processor.download_and_convert(url)\n        \n        if not result[\"success\"]:\n            error_msg = result[\"error\"]\n            # Check if it's a video unavailable error\n            if \"unavailable\" in error_msg.lower() or \"not available\" in error_msg.lower():\n                await query.edit_message_text(f\"‚ùå Video …ôl√ßatan deyil: {title}\\nZ…ôhm…ôt olmasa axtarƒ±≈ü n…ôtic…ôl…ôrind…ôn ba≈üqa mahnƒ± sƒ±nayƒ±n.\")\n            else:\n                await query.edit_message_text(f\"‚ùå Y√ºkl…ôn…ô bilm…ôdi: {title}\\n{error_msg}\")\n            return\n        \n        # Update progress\n        await query.edit_message_text(f\"üì§ Y√ºkl…ônir: {title}\")\n        \n        # Send the MP3 file\n        with open(result[\"file_path\"], 'rb') as audio_file:\n            # Clean title to avoid duplication\n            clean_title = result[\"title\"]\n            uploader = result[\"uploader\"]\n            \n            # If uploader is already in title, use title only\n            if uploader and uploader.lower() in clean_title.lower():\n                await context.bot.send_audio(\n                    chat_id=query.message.chat.id,\n                    audio=audio_file,\n                    title=clean_title,\n                    duration=result[\"duration\"]\n                )\n            else:\n                await context.bot.send_audio(\n                    chat_id=query.message.chat.id,\n                    audio=audio_file,\n                    title=clean_title,\n                    performer=uploader,\n                    duration=result[\"duration\"]\n                )\n        \n        # Update final message\n        await query.edit_message_text(f\"‚úÖ Y√ºkl…ôndi: {title}\")\n        \n        # Clean up the file\n        cleanup_temp_files([result[\"file_path\"]])\n        \n        # Clean up search results for this user\n        user_id = query.from_user.id\n        if user_id in user_search_results:\n            del user_search_results[user_id]\n        \n    except Exception as e:\n        logger.error(f\"Error processing URL from callback {url}: {str(e)}\")\n        # Check if it's a video unavailable error in the exception\n        if \"unavailable\" in str(e).lower() or \"not available\" in str(e).lower():\n            await query.edit_message_text(f\"‚ùå Video …ôl√ßatan deyil: {title}\\nZ…ôhm…ôt olmasa axtarƒ±≈ü n…ôtic…ôl…ôrind…ôn ba≈üqa mahnƒ± sƒ±nayƒ±n.\")\n        else:\n            await query.edit_message_text(f\"‚ùå Y√ºkl…ônm…ô x…ôtasƒ±: {title}\")\n\n# Keep old function name for compatibility\nurl_handler = message_handler\n\nasync def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Handle errors\"\"\"\n    logger.error(f\"Update {update} caused error {context.error}\")\n    \n    if update and update.message:\n        await update.message.reply_text(ERROR_MESSAGES[\"general_error\"])\n","size_bytes":12457},"bot/utils.py":{"content":"\"\"\"\nUtility functions for the Telegram YouTube to MP3 bot\n\"\"\"\n\nimport os\nimport re\nimport logging\nfrom pathlib import Path\nfrom typing import List\n\nlogger = logging.getLogger(__name__)\n\ndef is_valid_youtube_url(url: str) -> bool:\n    \"\"\"\n    Check if a URL is a valid YouTube URL\n    \n    Args:\n        url (str): URL to validate\n        \n    Returns:\n        bool: True if valid YouTube URL, False otherwise\n    \"\"\"\n    youtube_patterns = [\n        r'https?://(?:www\\.)?youtube\\.com/watch\\?v=[\\w-]+',\n        r'https?://(?:www\\.)?youtu\\.be/[\\w-]+',\n        r'https?://(?:www\\.)?m\\.youtube\\.com/watch\\?v=[\\w-]+',\n        r'https?://(?:www\\.)?youtube\\.com/embed/[\\w-]+',\n        r'https?://(?:www\\.)?youtube\\.com/v/[\\w-]+',\n    ]\n    \n    for pattern in youtube_patterns:\n        if re.match(pattern, url.strip()):\n            return True\n    \n    return False\n\ndef cleanup_temp_files(file_paths: List[str] = None) -> None:\n    \"\"\"\n    Clean up temporary files\n    \n    Args:\n        file_paths (List[str], optional): Specific files to delete.\n                                        If None, cleans all temp files.\n    \"\"\"\n    try:\n        if file_paths:\n            # Delete specific files\n            for file_path in file_paths:\n                if os.path.exists(file_path):\n                    os.remove(file_path)\n                    logger.info(f\"Deleted temp file: {file_path}\")\n        else:\n            # Clean all files in temp directory older than 1 hour\n            from config import TEMP_DIR\n            import time\n            \n            temp_path = Path(TEMP_DIR)\n            if not temp_path.exists():\n                return\n            \n            current_time = time.time()\n            for file_path in temp_path.iterdir():\n                if file_path.is_file():\n                    file_age = current_time - file_path.stat().st_mtime\n                    if file_age > 3600:  # 1 hour\n                        file_path.unlink()\n                        logger.info(f\"Cleaned old temp file: {file_path}\")\n                        \n    except Exception as e:\n        logger.error(f\"Error cleaning temp files: {str(e)}\")\n\ndef format_file_size(size_bytes: int) -> str:\n    \"\"\"\n    Format file size in human readable format\n    \n    Args:\n        size_bytes (int): Size in bytes\n        \n    Returns:\n        str: Formatted size string\n    \"\"\"\n    if size_bytes == 0:\n        return \"0 B\"\n    \n    size_names = [\"B\", \"KB\", \"MB\", \"GB\"]\n    import math\n    i = int(math.floor(math.log(size_bytes, 1024)))\n    p = math.pow(1024, i)\n    s = round(size_bytes / p, 2)\n    return f\"{s} {size_names[i]}\"\n\ndef sanitize_filename(filename: str) -> str:\n    \"\"\"\n    Sanitize filename for safe file system usage\n    \n    Args:\n        filename (str): Original filename\n        \n    Returns:\n        str: Sanitized filename\n    \"\"\"\n    # Remove or replace invalid characters\n    invalid_chars = '<>:\"/\\\\|?*'\n    for char in invalid_chars:\n        filename = filename.replace(char, '_')\n    \n    # Limit length\n    if len(filename) > 100:\n        filename = filename[:100]\n    \n    # Remove leading/trailing spaces and dots\n    filename = filename.strip(' .')\n    \n    return filename or \"audio\"\n\ndef get_video_id_from_url(url: str) -> str:\n    \"\"\"\n    Extract video ID from YouTube URL\n    \n    Args:\n        url (str): YouTube URL\n        \n    Returns:\n        str: Video ID or empty string if not found\n    \"\"\"\n    patterns = [\n        r'youtube\\.com/watch\\?v=([^&]+)',\n        r'youtu\\.be/([^?]+)',\n        r'youtube\\.com/embed/([^?]+)',\n        r'youtube\\.com/v/([^?]+)',\n    ]\n    \n    for pattern in patterns:\n        match = re.search(pattern, url)\n        if match:\n            return match.group(1)\n    \n    return \"\"\n","size_bytes":3729},"bot/youtube_processor.py":{"content":"\"\"\"\nYouTube video download and MP3 conversion processor\n\"\"\"\n\nimport os\nimport asyncio\nimport logging\nfrom pathlib import Path\nimport yt_dlp\nfrom config import (\n    TEMP_DIR, MAX_FILE_SIZE_BYTES, DOWNLOAD_TIMEOUT, \n    AUDIO_QUALITY, AUDIO_FORMAT, ERROR_MESSAGES\n)\n\nlogger = logging.getLogger(__name__)\n\nclass YouTubeProcessor:\n    \"\"\"Handles YouTube video downloading and MP3 conversion\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the processor\"\"\"\n        # Create temp directory if it doesn't exist\n        Path(TEMP_DIR).mkdir(exist_ok=True)\n        \n        # Configure yt-dlp options\n        self.ydl_opts = {\n            'format': 'bestaudio/best',\n            'outtmpl': f'{TEMP_DIR}/%(title)s.%(ext)s',\n            'extractaudio': True,\n            'audioformat': AUDIO_FORMAT,\n            'audioquality': AUDIO_QUALITY,\n            'postprocessors': [{\n                'key': 'FFmpegExtractAudio',\n                'preferredcodec': AUDIO_FORMAT,\n                'preferredquality': AUDIO_QUALITY,\n            }],\n            'quiet': True,\n            'no_warnings': True,\n            # Add options to handle YouTube's anti-bot measures\n            'cookiefile': None,\n            'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n            'extractor_retries': 3,\n            'fragment_retries': 3,\n            'retry_sleep_functions': {'http': lambda n: min(4 ** n, 60)},\n            'socket_timeout': 30,\n        }\n    \n    async def download_and_convert(self, url: str) -> dict:\n        \"\"\"\n        Download YouTube video and convert to MP3\n        \n        Args:\n            url (str): YouTube video URL\n            \n        Returns:\n            dict: Result containing success status, file path, and metadata\n        \"\"\"\n        try:\n            # Run the download in a thread with a simpler approach\n            loop = asyncio.get_event_loop()\n            result = await loop.run_in_executor(None, self._download_video, url)\n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error downloading {url}: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": ERROR_MESSAGES[\"download_failed\"]\n            }\n    \n    def _download_video(self, url: str) -> dict:\n        \"\"\"\n        Synchronous download function to run in executor\n        \n        Args:\n            url (str): YouTube video URL\n            \n        Returns:\n            dict: Result containing success status, file path, and metadata\n        \"\"\"\n        try:\n            logger.info(f\"Starting download for URL: {url}\")\n            \n            # Simplified options for better reliability\n            ydl_opts = {\n                'format': 'bestaudio/best',\n                'outtmpl': f'{TEMP_DIR}/%(title)s.%(ext)s',\n                'postprocessors': [{\n                    'key': 'FFmpegExtractAudio',\n                    'preferredcodec': 'mp3',\n                    'preferredquality': '192',\n                }],\n                'quiet': False,  # Enable output for debugging\n                'no_warnings': False,\n                'socket_timeout': 15,\n                'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n                'extractor_retries': 1,  # Reduce retries for faster failure\n                'fragment_retries': 1,\n            }\n            \n            logger.info(\"Creating yt-dlp instance...\")\n            with yt_dlp.YoutubeDL(ydl_opts) as ydl:\n                # Extract video info first\n                logger.info(\"Extracting video information...\")\n                try:\n                    info = ydl.extract_info(url, download=False)\n                    if info:\n                        logger.info(f\"Video info extraction completed: {info.get('title', 'Unknown')}\")\n                    else:\n                        logger.error(\"Video info extraction returned None\")\n                except Exception as extract_error:\n                    logger.error(f\"Failed to extract video info: {extract_error}\")\n                    raise extract_error\n                \n                # Check if video is available\n                if not info:\n                    logger.error(\"Failed to extract video information\")\n                    return {\n                        \"success\": False,\n                        \"error\": ERROR_MESSAGES[\"download_failed\"]\n                    }\n                \n                # Get video metadata\n                title = info.get('title', 'Unknown Title')\n                uploader = info.get('uploader', 'Unknown Artist')\n                duration = info.get('duration', 0)\n                \n                logger.info(f\"Video info - Title: {title}, Duration: {duration}s, Uploader: {uploader}\")\n                \n                # Estimate file size (rough approximation)\n                estimated_size = duration * 24000  # ~192kbps in bytes per second\n                if estimated_size > MAX_FILE_SIZE_BYTES:\n                    logger.error(f\"File too large: estimated {estimated_size} bytes\")\n                    return {\n                        \"success\": False,\n                        \"error\": ERROR_MESSAGES[\"file_too_large\"]\n                    }\n                \n                # Download and convert\n                logger.info(\"Starting download and conversion...\")\n                ydl.download([url])\n                logger.info(\"Download completed, looking for converted file...\")\n                \n                # Find the converted file\n                file_path = self._find_converted_file(title)\n                if not file_path or not os.path.exists(file_path):\n                    logger.error(f\"Converted file not found. Expected pattern: {title}\")\n                    # List files in temp directory for debugging\n                    temp_files = os.listdir(TEMP_DIR) if os.path.exists(TEMP_DIR) else []\n                    logger.error(f\"Files in temp directory: {temp_files}\")\n                    return {\n                        \"success\": False,\n                        \"error\": ERROR_MESSAGES[\"conversion_failed\"]\n                    }\n                \n                logger.info(f\"Found converted file: {file_path}\")\n                \n                # Check actual file size\n                file_size = os.path.getsize(file_path)\n                if file_size > MAX_FILE_SIZE_BYTES:\n                    logger.error(f\"File too large after conversion: {file_size} bytes\")\n                    os.remove(file_path)\n                    return {\n                        \"success\": False,\n                        \"error\": ERROR_MESSAGES[\"file_too_large\"]\n                    }\n                \n                logger.info(f\"Conversion successful! File size: {file_size} bytes\")\n                return {\n                    \"success\": True,\n                    \"file_path\": file_path,\n                    \"title\": title,\n                    \"uploader\": uploader,\n                    \"duration\": duration,\n                    \"file_size\": file_size\n                }\n                \n        except Exception as e:\n            logger.error(f\"Download error: {str(e)}\")\n            import traceback\n            logger.error(f\"Traceback: {traceback.format_exc()}\")\n            return {\n                \"success\": False,\n                \"error\": ERROR_MESSAGES[\"download_failed\"]\n            }\n    \n    async def search_youtube(self, query: str, max_results: int = 24) -> list:\n        \"\"\"\n        Search YouTube for videos by query\n        \n        Args:\n            query (str): Search query\n            max_results (int): Maximum number of results to return (max 24 for 3 pages)\n            \n        Returns:\n            list: List of video dictionaries with title, url, and uploader\n        \"\"\"\n        try:\n            loop = asyncio.get_event_loop()\n            result = await loop.run_in_executor(None, self._search_youtube_sync, query, max_results)\n            return result\n        except Exception as e:\n            logger.error(f\"Error searching YouTube for '{query}': {str(e)}\")\n            return []\n    \n    def _search_youtube_sync(self, query: str, max_results: int = 24) -> list:\n        \"\"\"\n        Synchronous YouTube search function to run in executor\n        \n        Args:\n            query (str): Search query\n            max_results (int): Maximum number of results to return\n            \n        Returns:\n            list: List of video dictionaries\n        \"\"\"\n        try:\n            search_opts = {\n                'quiet': True,\n                'no_warnings': True,\n                'extract_flat': True,  # Don't download, just get metadata\n                'default_search': 'ytsearch',\n            }\n            \n            with yt_dlp.YoutubeDL(search_opts) as ydl:\n                # Search for videos\n                search_query = f\"ytsearch{max_results}:{query}\"\n                search_results = ydl.extract_info(search_query, download=False)\n                \n                videos = []\n                if search_results and 'entries' in search_results:\n                    for entry in search_results['entries']:\n                        if entry:\n                            video_id = entry.get('id', '')\n                            # Skip if no video ID or if it's a playlist/channel\n                            if not video_id or len(video_id) != 11:\n                                continue\n                            \n                            # Basic filtering for obviously problematic entries\n                            title = entry.get('title', 'Unknown Title')\n                            if not title or title in ['[Deleted video]', '[Private video]', 'Deleted video', 'Private video']:\n                                continue\n                                \n                            videos.append({\n                                'title': title,\n                                'url': f\"https://www.youtube.com/watch?v={video_id}\",\n                                'uploader': entry.get('uploader', 'Unknown Artist'),\n                                'duration': entry.get('duration', 0),\n                                'id': video_id\n                            })\n                \n                logger.info(f\"Found {len(videos)} videos for query: {query}\")\n                return videos\n                \n        except Exception as e:\n            logger.error(f\"Search error: {str(e)}\")\n            return []\n\n    def _find_converted_file(self, title: str) -> str:\n        \"\"\"\n        Find the converted MP3 file\n        \n        Args:\n            title (str): Video title\n            \n        Returns:\n            str: Path to the MP3 file\n        \"\"\"\n        # Clean title for filename matching\n        clean_title = \"\".join(c for c in title if c.isalnum() or c in (' ', '-', '_')).rstrip()\n        \n        # Look for files in temp directory\n        temp_path = Path(TEMP_DIR)\n        \n        # Try exact match first\n        exact_match = temp_path / f\"{clean_title}.{AUDIO_FORMAT}\"\n        if exact_match.exists():\n            return str(exact_match)\n        \n        # Look for any MP3 files that might match\n        for file_path in temp_path.glob(f\"*.{AUDIO_FORMAT}\"):\n            if clean_title.lower() in file_path.stem.lower():\n                return str(file_path)\n        \n        # Return the most recent MP3 file as fallback\n        mp3_files = list(temp_path.glob(f\"*.{AUDIO_FORMAT}\"))\n        if mp3_files:\n            return str(max(mp3_files, key=os.path.getctime))\n        \n        return \"\"\n","size_bytes":11630}}}